import {
/* Tailwind classes used for styling */
  BugReport as BugReportIcon,
  ExpandLess as ExpandLessIcon,
  ExpandMore as ExpandMoreIcon,
  Home as HomeIcon,
  Refresh as RefreshIcon,
} from '@mui/icons-material';
import { Alert,
  AlertTitle, Button,
  Collapse,
  IconButton,
  Paper,
  Stack,
  Typography, } from '@mui/material';
import type { ErrorInfo, ReactNode } from 'react';
import { Component } from 'react';
// 游댃 MOBILE CLEANUP: mobileLogger removed
// import { getMobileLogger } from '../../utils/mobileLogger';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
  maxRetries?: number;
  level?: 'page' | 'component' | 'section';
}

interface State {
  hasError: boolean;
  error: Error | null;
  errorInfo?: ErrorInfo;
  retryCount: number;
  showDetails: boolean;
}

class ErrorBoundary extends Component<Props, State> {
  private retryTimeouts: ReturnType<typeof setTimeout>[] = [];

  public state: State = {
    hasError: false,
    error: null,
    errorInfo: undefined,
    retryCount: 0,
    showDetails: false,
  };

  public static getDerivedStateFromError(error: Error): Partial<State> {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    this.setState({ errorInfo });

    console.group('游뚿 ErrorBoundary caught an error');
    console.error('Error:', error);
    console.error('Component Stack:', errorInfo.componentStack);
    console.groupEnd();

    // Report to MobileLogger with enhanced context
    // 游댃 MOBILE CLEANUP: mobileLogger disabled
    const mobileLogger = null; // getMobileLogger();
    if (mobileLogger) {
      // mobileLogger.log('CRITICAL', 'ErrorBoundary', 'React Error Boundary caught error', {
      // error: error.message,
      // stack: error.stack,
      // componentStack: errorInfo.componentStack,
      // errorBoundary: true,
      // retryCount: this.state.retryCount,
      // level: this.props.level || 'component',
      // });
    }

    // Auto-retry for certain recoverable errors
    if (
      this.shouldAutoRetry(error) &&
      this.state.retryCount < (this.props.maxRetries || 2)
    ) {
      const timeout = setTimeout(
        () => {
          this.handleRetry();
        },
        1000 * (this.state.retryCount + 1)
      );

      this.retryTimeouts.push(timeout);
    }
  }

  componentWillUnmount() {
    this.retryTimeouts.forEach(timeout => clearTimeout(timeout));
  }

  private shouldAutoRetry = (error: Error): boolean => {
    const recoverableErrors = [
      'ChunkLoadError',
      'Loading chunk',
      'Network Error',
      'Failed to fetch',
    ];

    return recoverableErrors.some(
      pattern => error.message.includes(pattern) || error.name.includes(pattern)
    );
  };

  private handleRetry = () => {
    this.setState(prevState => ({
      hasError: false,
      error: null,
      errorInfo: undefined,
      retryCount: prevState.retryCount + 1,
      showDetails: false,
    }));
  };

  private handleReload = () => {
    window.location.reload();
  };

  private handleGoHome = () => {
    window.location.href = '/';
  };

  private toggleDetails = () => {
    this.setState(prevState => ({
      showDetails: !prevState.showDetails,
    }));
  };

  private getErrorMessage = (): string => {
    const { error } = this.state;

    if (!error) return 'Nezn치ma chyba';

    if (
      error.message.includes('ChunkLoadError') ||
      error.message.includes('Loading chunk')
    ) {
      // 游댌 IMPROVED: Lep코ie logovanie pre mobile chunk errors
      const isMobile =
        typeof window !== 'undefined' &&
        window.matchMedia &&
        window.matchMedia('(max-width: 900px)').matches;
      const hasAutoReloaded =
        sessionStorage.getItem('autoReloadedAfterChunkError') === '1';

      console.group('游뚿 ChunkLoadError detected');
      console.log('Is Mobile:', isMobile);
      console.log('Has Auto Reloaded:', hasAutoReloaded);
      console.log('Current URL:', window.location.href);
      console.log('User Agent:', navigator.userAgent);
      console.log(
        'Connection:',
        (navigator as Navigator & { connection?: unknown }).connection
      );
      console.groupEnd();

      // 游댌 CHANGE: Prid치me delay a user confirmation na mobile
      if (isMobile && !hasAutoReloaded) {
        sessionStorage.setItem('autoReloadedAfterChunkError', '1');

        // 游뛂 TEMPORARILY DISABLED: Automatic reload on ChunkLoadError
        // This might be causing the mobile refresh issues

        console.log(
          '游뚿 ChunkLoadError detected but auto-reload is DISABLED for debugging'
        );
        console.log('游님 Mobile users should manually refresh if needed');

        // P칎VODN칗 K칍D (ZAK츼ZAN칗):
        // if (process.env.NODE_ENV === 'development') {
        //   const shouldReload = window.confirm('游뚿 ChunkLoadError na mobile!\n\nChcete automaticky obnovi콘 str치nku?\n(Cancel = ponecha콘 pre debugging)');
        //   if (shouldReload) {
        //     setTimeout(() => window.location.reload(), 100);
        //   }
        // } else {
        //   setTimeout(() => window.location.reload(), 1000);
        // }
      }
      return 'Na캜칤tavanie str치nky bolo preru코en칠. Sk칰ste obnovi콘 str치nku.';
    }

    if (
      error.message.includes('Network Error') ||
      error.message.includes('Failed to fetch')
    ) {
      return 'Probl칠m s pripojen칤m. Skontrolujte internetov칠 pripojenie.';
    }

    if (error.name === 'TypeError') {
      return 'Nastala technick치 chyba. Sk칰ste obnovi콘 str치nku.';
    }

    return 'Nastala neo캜ak치van치 chyba. Sk칰ste to znovu.';
  };

  public render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      const { level = 'component', maxRetries = 2 } = this.props;
      const { error, retryCount, showDetails } = this.state;
      const canRetry = retryCount < maxRetries;

      // Different layouts based on error level
      if (level === 'page') {
        return (
          <div
            display="flex"
            justifyContent="center"
            alignItems="center"
            minHeight="100vh"
            p={2}
            bgcolor="background.default"
          >
            <Paper elevation={3} className="p-8 /* TODO: Convert maxWidth: 700 */">
              <Alert severity="error" className="/* TODO: Convert mb: 3 */">
                <AlertTitle
                  className="/* TODO: Convert display: flex */ /* TODO: Convert alignItems: center */ gap-2"
                >
                  <BugReportIcon />
                  Str치nka sa nena캜칤tala spr치vne
                </AlertTitle>
                <Typography variant="body2">
                  {this.getErrorMessage()}
                </Typography>
              </Alert>

              <Stack
                direction="row"
                spacing={2}
                className="/* TODO: Convert mb: 2 */ /* TODO: Convert justifyContent: center */"
              >
                {canRetry && (
                  <Button
                    variant="contained"
                    startIcon={<RefreshIcon />}
                    onClick={this.handleRetry}
                  >
                    Sk칰si콘 znovu ({retryCount}/{maxRetries})
                  </Button>
                )}

                <Button
                  variant="outlined"
                  startIcon={<RefreshIcon />}
                  onClick={this.handleReload}
                >
                  Obnovi콘 str치nku
                </Button>

                <Button
                  variant="text"
                  startIcon={<HomeIcon />}
                  onClick={this.handleGoHome}
                >
                  Domov
                </Button>
              </Stack>

              {/* Technical details for developers */}
              <div>
                <Button
                  size="small"
                  onClick={this.toggleDetails}
                  startIcon={
                    showDetails ? <ExpandLessIcon /> : <ExpandMoreIcon />
                  }
                  className="/* TODO: Convert mb: 1 */"
                >
                  Technick칠 detaily
                </Button>

                <Collapse in={showDetails}>
                  <Paper className="p-4 /* TODO: Convert bgcolor: grey.50 */">
                    {process.env.NODE_ENV === 'development' && error && (
                      <>
                        <Typography
                          variant="caption"
                          className="/* TODO: Convert fontWeight: bold */ /* TODO: Convert display: block */ /* TODO: Convert mb: 1 */"
                        >
                          Chybov치 spr치va:
                        </Typography>
                        <Typography
                          variant="body2"
                          className="/* TODO: Convert fontFamily: monospace */ /* TODO: Convert mb: 2 */"
                        >
                          {error.toString()}
                        </Typography>

                        {error.stack && (
                          <div
                            component="pre"
                            className="/* TODO: Convert fontSize: 0.75rem */ /* TODO: Convert overflow: auto */ /* TODO: Convert maxHeight: 200 */ /* TODO: Convert bgcolor: grey.100 */ p-2 rounded"
                          >
                            {error.stack}
                          </div>
                        )}
                      </>
                    )}

                    <Typography variant="caption" color="text.secondary">
                      Chyba bola automaticky nahl치sen치 a bude opraven치 캜o
                      najsk칪r.
                    </Typography>
                  </Paper>
                </Collapse>
              </div>
            </Paper>
          </div>
        );
      }

      // Component-level error (smaller, inline)
      return (
        <Alert
          severity="error"
          className="m-4"
          action={
            <Stack direction="row" spacing={1}>
              {canRetry && (
                <IconButton size="small" onClick={this.handleRetry}>
                  <RefreshIcon />
                </IconButton>
              )}
              {showDetails && (
                <IconButton size="small" onClick={this.toggleDetails}>
                  {showDetails ? <ExpandLessIcon /> : <ExpandMoreIcon />}
                </IconButton>
              )}
            </Stack>
          }
        >
          <AlertTitle>Chyba v komponente</AlertTitle>
          <Typography variant="body2" className="/* TODO: Convert mb: 1 */">
            {this.getErrorMessage()}
          </Typography>

          {retryCount > 0 && (
            <Typography
              variant="caption"
              className="/* TODO: Convert display: block */ /* TODO: Convert opacity: 0.7 */"
            >
              Po캜et pokusov: {retryCount}/{maxRetries}
            </Typography>
          )}

          <Collapse in={showDetails}>
            <div
              className="/* TODO: Convert mt: 2 */ p-2 /* TODO: Convert bgcolor: rgba(0 */ rounded"
            >
              <Typography variant="caption">
                {process.env.NODE_ENV === 'development' && error?.message}
              </Typography>
            </div>
          </Collapse>
        </Alert>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
