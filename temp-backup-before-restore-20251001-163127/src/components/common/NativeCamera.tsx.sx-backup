import {
/* Tailwind classes used for styling */
  CheckCircle,
  Close,
  FlashOff,
  FlashOn,
  FlipCameraIos,
  PhotoCamera,
} from '@mui/icons-material';
import { Alert, Button,
  Chip,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  IconButton,
  LinearProgress,
  Typography, } from '@mui/material';
import { useCallback, useEffect, useRef, useState } from 'react';

import { isWebPSupported } from '../../utils/imageLint';
import { logger } from '../../utils/logger';

interface NativeCameraProps {
  open: boolean;
  onClose: () => void;
  onCapture: (imageBlob: Blob) => void;
  title?: string;
  maxPhotos?: number;
  currentPhotoCount?: number;
  enableVideo?: boolean;
}

interface CameraState {
  stream: MediaStream | null;
  isInitializing: boolean;
  error: string | null;
  facingMode: 'environment' | 'user';
  flashSupported: boolean;
  flashEnabled: boolean;
}

export default function NativeCamera({
  open,
  onClose,
  onCapture,
  title = 'Nat√≠vna kamera',
  maxPhotos = 50,
  currentPhotoCount = 0,
}: NativeCameraProps) {
  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const streamRef = useRef<MediaStream | null>(null);

  const [cameraState, setCameraState] = useState<CameraState>({
    stream: null,
    isInitializing: false,
    error: null,
    facingMode: 'environment', // Zadn√° kamera
    flashSupported: false,
    flashEnabled: false,
  });

  const [capturing, setCapturing] = useState(false);
  const [photosInSession, setPhotosInSession] = useState(0);
  const [webPSupported, setWebPSupported] = useState<boolean | null>(null);

  // Inicializ√°cia kamery
  const initCamera = useCallback(
    async (facingMode: 'environment' | 'user' = 'environment') => {
      logger.debug('üöÄ Starting camera initialization...');
      setCameraState(prev => ({ ...prev, isInitializing: true, error: null }));

      // Kontrola podpory MediaDevices API
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        const errorMsg =
          'MediaDevices API nie je podporovan√© v tomto prehliadaƒçi.';
        console.error('‚ùå', errorMsg);
        setCameraState(prev => ({
          ...prev,
          isInitializing: false,
          error: errorMsg,
          stream: null,
        }));
        return;
      }

      try {
        // Zastavenie existuj√∫ceho streamu
        if (streamRef.current) {
          logger.debug('üõë Stopping existing stream...');
          streamRef.current.getTracks().forEach(track => track.stop());
          streamRef.current = null;
        }

        // Nastavenie constraints pre kameru s vy≈°≈°√≠m rozl√≠≈°en√≠m
        const constraints: MediaStreamConstraints = {
          video: {
            facingMode: facingMode,
            width: { ideal: 1920, max: 3840 }, // ‚úÖ Zv√Ω≈°en√© rozl√≠≈°enie
            height: { ideal: 1080, max: 2160 }, // ‚úÖ Zv√Ω≈°en√© rozl√≠≈°enie
          },
          audio: false,
        };

        logger.debug('üì± Requesting camera with constraints:', constraints);

        // Timeout pre loading state (5 sek√∫nd)
        const timeoutId = setTimeout(() => {
          console.error('‚è∞ Camera initialization timeout');
          setCameraState(prev => ({
            ...prev,
            isInitializing: false,
            error:
              'ƒåasov√Ω limit pre spustenie kamery vypr≈°al. Sk√∫ste to znovu.',
            stream: null,
          }));
        }, 5000);

        try {
          // Z√≠skanie stream z kamery
          const stream = await navigator.mediaDevices.getUserMedia(constraints);

          // Zastavi≈• timeout ak sa stream podarilo z√≠ska≈•
          clearTimeout(timeoutId);

          logger.debug('‚úÖ Stream z√≠skan√Ω:', stream);
          logger.debug('üìπ Video tracks:', stream.getVideoTracks());

          // Poƒçkaj na video element (m√¥≈æe trva≈• chv√≠ƒæu k√Ωm sa vytvor√≠)
          let retries = 0;
          const maxRetries = 10;

          const setupVideo = () => {
            if (videoRef.current) {
              logger.debug('‚úÖ Video ref found, setting up stream');
              videoRef.current.srcObject = stream;

              // Poƒçkaj na loadedmetadata event
              videoRef.current.onloadedmetadata = () => {
                logger.debug('‚úÖ Video metadata loaded');
                if (videoRef.current) {
                  videoRef.current.play().catch(err => {
                    console.error('‚ùå Video play error:', err);
                  });
                }
              };
            } else {
              retries++;
              if (retries < maxRetries) {
                logger.debug(
                  `üîÑ Video ref not ready, retry ${retries}/${maxRetries}`
                );
                setTimeout(setupVideo, 100);
              } else {
                logger.error(
                  '‚ùå Video ref never became available after retries'
                );
                setCameraState(prev => ({
                  ...prev,
                  error:
                    'Nepodarilo sa pripoji≈• video element. Sk√∫ste obnovi≈• str√°nku.',
                  isInitializing: false,
                }));
                return;
              }
            }
          };

          // Mal√© oneskorenie pre lep≈°iu stabilitu
          setTimeout(setupVideo, 50);

          // Kontrola flash podpory
          const videoTrack = stream.getVideoTracks()[0];
          const capabilities = videoTrack.getCapabilities?.();
          const flashSupported =
            capabilities &&
            'torch' in capabilities &&
            (capabilities as Record<string, unknown>).torch === true;

          logger.debug('üî¶ Flash supported:', flashSupported);

          setCameraState(prev => ({
            ...prev,
            stream,
            isInitializing: false,
            facingMode,
            flashSupported,
            error: null,
          }));

          // Ulo≈æi≈• stream do ref pre cleanup
          streamRef.current = stream;
        } catch (error) {
          // Zastavi≈• timeout pri chybe
          clearTimeout(timeoutId);

          throw error; // Re-throw pre vonkaj≈°√≠ catch
        }
      } catch (error) {
        console.error('‚ùå Chyba pri inicializ√°cii kamery:', error);
        let errorMessage = 'Nepodarilo sa spusti≈• kameru';

        if (error instanceof Error) {
          console.error('Error name:', error.name);
          console.error('Error message:', error.message);

          if (error.name === 'NotAllowedError') {
            errorMessage =
              'Pr√≠stup ku kamere bol zamietnut√Ω.\n\nPovoƒæte pr√≠stup ku kamere:\n1. Kliknite na ikonu üîí v adresnom riadku\n2. Povoƒæte kameru pre t√∫to str√°nku\n3. Obnovte str√°nku';
          } else if (error.name === 'NotFoundError') {
            errorMessage =
              'Kamera nebola n√°jden√° na tomto zariaden√≠.\n\nSkontrolujte ƒçi:\n‚Ä¢ M√°te kameru pripojenu\n‚Ä¢ Kamera nie je pou≈æ√≠van√° inou aplik√°ciou';
          } else if (error.name === 'NotSupportedError') {
            errorMessage =
              'Kamera nie je podporovan√° v tomto prehliadaƒçi.\n\nSk√∫ste:\n‚Ä¢ Chrome, Safari alebo Firefox\n‚Ä¢ HTTPS pripojenie';
          } else if (error.name === 'OverconstrainedError') {
            errorMessage =
              'Po≈æadovan√© nastavenia kamery nie s√∫ podporovan√©.\n\nSk√∫ste re≈°tartova≈• kameru.';
          }
        }

        setCameraState(prev => ({
          ...prev,
          isInitializing: false,
          error: errorMessage,
          stream: null,
        }));
      }
    },
    []
  ); // Pr√°zdne dependencies!

  // üîç Detekcia WebP podpory pri naƒç√≠tan√≠
  useEffect(() => {
    isWebPSupported().then(setWebPSupported);
  }, []);

  // Spustenie kamery pri otvoren√≠ dial√≥gu
  useEffect(() => {
    if (open) {
      logger.debug('üé¨ NativeCamera opening, initializing...');
      setPhotosInSession(0);
      initCamera();
    } else {
      logger.debug('üö™ NativeCamera closing, cleaning up...');
      // Zastavenie kamery pri zatvoren√≠
      if (streamRef.current) {
        streamRef.current.getTracks().forEach(track => {
          logger.debug('üõë Stopping track:', track.kind);
          track.stop();
        });
        streamRef.current = null;
        setCameraState(prev => ({ ...prev, stream: null }));
      }
    }

    return () => {
      if (streamRef.current) {
        logger.debug('üßπ Cleanup: stopping all tracks');
        streamRef.current.getTracks().forEach(track => track.stop());
        streamRef.current = null;
      }
    };
  }, [open, initCamera]); // Pridan√© initCamera dependency

  // Prepnutie kamery (predn√°/zadn√°)
  const switchCamera = async () => {
    const newFacingMode =
      cameraState.facingMode === 'environment' ? 'user' : 'environment';
    await initCamera(newFacingMode);
  };

  // Zapnutie/vypnutie flash
  const toggleFlash = async () => {
    if (!streamRef.current || !cameraState.flashSupported) return;

    try {
      const videoTrack = streamRef.current.getVideoTracks()[0];
      await videoTrack.applyConstraints({
        advanced: [
          { torch: !cameraState.flashEnabled } as Record<string, unknown>,
        ],
      });

      setCameraState(prev => ({
        ...prev,
        flashEnabled: !prev.flashEnabled,
      }));
    } catch (error) {
      console.error('Chyba pri prep√≠nan√≠ flash:', error);
    }
  };

  // Zachytenie fotky - KƒΩ√öƒåOV√Å FUNKCIA!
  const capturePhoto = useCallback(async () => {
    if (!videoRef.current || !canvasRef.current || capturing) return;

    if (currentPhotoCount + photosInSession >= maxPhotos) {
      alert(`M√¥≈æete prida≈• maxim√°lne ${maxPhotos} fotiek.`);
      return;
    }

    setCapturing(true);

    try {
      const video = videoRef.current;
      const canvas = canvasRef.current;
      const context = canvas.getContext('2d');

      if (!context) {
        throw new Error('Canvas context nie je dostupn√Ω');
      }

      // Nastavenie veƒækosti canvas podƒæa videa
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;

      // Vykreslenie aktu√°lneho frame z videa na canvas
      context.drawImage(video, 0, 0, canvas.width, canvas.height);

      // üåü NOV√â: Inteligentn√° WebP konverzia s fallback
      const captureWithFormat = () => {
        if (webPSupported) {
          // WebP capture s plnou kvalitou
          canvas.toBlob(
            blob => {
              if (blob) {
                logger.debug(
                  '‚úÖ WebP capture successful, size:',
                  (blob.size / 1024).toFixed(1) + 'KB'
                );
                onCapture(blob);
                setPhotosInSession(prev => prev + 1);
                setTimeout(() => setCapturing(false), 200);
              } else {
                console.warn('‚ö†Ô∏è WebP failed, trying JPEG fallback');
                captureJPEG();
              }
            },
            'image/webp',
            0.95 // 95% kvalita pre WebP (lep≈°ia kompresia)
          );
        } else {
          // Priamy JPEG capture
          captureJPEG();
        }
      };

      const captureJPEG = () => {
        canvas.toBlob(
          blob => {
            if (blob) {
              logger.debug(
                '‚úÖ JPEG capture successful, size:',
                (blob.size / 1024).toFixed(1) + 'KB'
              );
              onCapture(blob);
              setPhotosInSession(prev => prev + 1);
              setTimeout(() => setCapturing(false), 200);
            } else {
              setCapturing(false);
              console.error('‚ùå JPEG capture failed');
            }
          },
          'image/jpeg',
          0.95 // 95% kvalita pre JPEG
        );
      };

      // Spusti capture s detekovan√Ωm form√°tom
      captureWithFormat();
    } catch (error) {
      console.error('Chyba pri zachyt√°van√≠ fotky:', error);
      setCapturing(false);
      alert(
        'Chyba pri zachyt√°van√≠ fotky: ' +
          (error instanceof Error ? error.message : 'Nezn√°ma chyba')
      );
    }
  }, [
    capturing,
    currentPhotoCount,
    photosInSession,
    maxPhotos,
    onCapture,
    webPSupported,
  ]);

  // Keyboard shortcuts (medzern√≠k = fotka!)
  useEffect(() => {
    const handleKeyPress = (event: KeyboardEvent) => {
      if (!open) return;

      if (event.code === 'Space' || event.code === 'Enter') {
        event.preventDefault();
        capturePhoto();
      } else if (event.code === 'Escape') {
        onClose();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [open, capturePhoto, onClose]);

  if (!open) return null;

  return (
    <Dialog
      open={open}
      onClose={onClose}
      maxWidth="md"
      fullWidth
      fullScreen // Pre mobiln√© zariadenia
      PaperProps={{
        sx: {
          bgcolor: 'black',
          color: 'white',
          height: '100vh',
          margin: 0,
        },
      }}
    >
      <DialogTitle
        className="/* TODO: Convert display: flex */ /* TODO: Convert justifyContent: space-between */ /* TODO: Convert alignItems: center */ /* TODO: Convert bgcolor: rgba(0 */ /* TODO: Convert color: white */ /* TODO: Convert py: 1 */ /* TODO: Convert position: relative */ /* TODO: Convert zIndex: 10 */"
      >
        <Typography component="span" variant="h6" className="/* TODO: Convert color: white */">
          {title}
        </Typography>
        <div className="/* TODO: Convert display: flex */ /* TODO: Convert alignItems: center */ gap-2">
          {webPSupported !== null && (
            <Chip
              label={webPSupported ? 'WebP ‚úÖ' : 'JPEG'}
              size="small"
              color={webPSupported ? 'success' : 'default'}
              className="/* TODO: Convert color: white */ /* TODO: Convert borderColor: white */ /* TODO: Convert bgcolor: webPSupported
                  ? rgba(76 */ /* TODO: Convert 0.3)
                  : rgba(255 */"
              variant="outlined"
            />
          )}
          <Chip
            label={`${currentPhotoCount + photosInSession}/${maxPhotos}`}
            size="small"
            color="primary"
            className="/* TODO: Convert color: white */ /* TODO: Convert borderColor: white */"
            variant="outlined"
          />
          <IconButton
            onClick={onClose}
            sx={{
              color: 'white',
              bgcolor: 'rgba(255,255,255,0.1)',
              '&:hover': {
                bgcolor: 'rgba(255,255,255,0.2)',
              },
              ml: 1,
            }}
          >
            <Close />
          </IconButton>
        </div>
      </DialogTitle>

      <DialogContent
        className="/* TODO: Convert p: 0 */ /* TODO: Convert bgcolor: black */ /* TODO: Convert position: relative */ /* TODO: Convert flex: 1 */"
      >
        {cameraState.error ? (
          <div className="p-6">
            <Alert severity="error" className="/* TODO: Convert mb: 2 */">
              {cameraState.error}
            </Alert>
            <Button variant="contained" onClick={() => initCamera()}>
              Sk√∫si≈• znovu
            </Button>
          </div>
        ) : cameraState.isInitializing ? (
          <div
            className="p-6 /* TODO: Convert display: flex */ /* TODO: Convert flexDirection: column */ /* TODO: Convert alignItems: center */ /* TODO: Convert justifyContent: center */ /* TODO: Convert height: 100% */ /* TODO: Convert minHeight: 300px */"
          >
            <Typography
              variant="body1"
              className="/* TODO: Convert color: white */ /* TODO: Convert mb: 2 */ /* TODO: Convert textAlign: center */"
            >
              Sp√∫≈°≈•am kameru...
            </Typography>
            <LinearProgress className="/* TODO: Convert width: 100% */ /* TODO: Convert maxWidth: 300px */" />
            <Typography
              variant="caption"
              className="/* TODO: Convert color: rgba(255 */ /* TODO: Convert mt: 2 */ /* TODO: Convert textAlign: center */"
            >
              Povoƒæte pr√≠stup ku kamere v prehliadaƒçi
            </Typography>
          </div>
        ) : (
          <>
            {/* Video preview - LIVE CAMERA FEED */}
            <div
              className="/* TODO: Convert position: relative */ /* TODO: Convert width: 100% */ /* TODO: Convert height: 100% */ /* TODO: Convert display: flex */ /* TODO: Convert alignItems: center */ /* TODO: Convert justifyContent: center */ /* TODO: Convert minHeight: 400px */"
            >
              <video
                ref={videoRef}
                autoPlay
                playsInline
                muted
                onCanPlay={() => logger.debug('‚úÖ Video can play')}
                onError={e => console.error('‚ùå Video error:', e)}
                style={{
                  width: '100%',
                  height: '100%',
                  objectFit: 'cover',
                }}
              />

              {/* Canvas for capture (hidden) */}
              <canvas ref={canvasRef} style={{ display: 'none' }} />

              {/* Camera controls overlay */}
              {cameraState.stream && (
                <div
                  className="/* TODO: Convert position: absolute */ /* TODO: Convert bottom: 20 */ /* TODO: Convert left: 50% */ /* TODO: Convert transform: translateX(-50%) */ /* TODO: Convert display: flex */ /* TODO: Convert alignItems: center */ gap-6 /* TODO: Convert bgcolor: rgba(0 */ /* TODO: Convert borderRadius: 6 */ p-4"
                >
                  {/* Flash toggle */}
                  {cameraState.flashSupported && (
                    <IconButton
                      onClick={toggleFlash}
                      className="/* TODO: Convert color: cameraState.flashEnabled ? yellow : white */ /* TODO: Convert bgcolor: cameraState.flashEnabled
                          ? rgba(255 */ /* TODO: Convert 0.2)
                          : transparent */"
                    >
                      {cameraState.flashEnabled ? <FlashOn /> : <FlashOff />}
                    </IconButton>
                  )}

                  {/* üì∏ CAPTURE BUTTON - KƒΩ√öƒåOV√â TLAƒåIDLO! */}
                  <IconButton
                    onClick={capturePhoto}
                    disabled={capturing}
                    sx={{
                      bgcolor: capturing ? 'green' : 'white',
                      color: capturing ? 'white' : 'black',
                      width: 70,
                      height: 70,
                      '&:hover': {
                        bgcolor: capturing ? 'green' : 'rgba(255,255,255,0.8)',
                      },
                      border: '3px solid white',
                    }}
                  >
                    {capturing ? (
                      <CheckCircle />
                    ) : (
                      <PhotoCamera className="/* TODO: Convert fontSize: 30 */" />
                    )}
                  </IconButton>

                  {/* Camera switch */}
                  <IconButton onClick={switchCamera} className="/* TODO: Convert color: white */">
                    <FlipCameraIos />
                  </IconButton>
                </div>
              )}

              {/* Instructions */}
              {cameraState.stream && photosInSession === 0 && (
                <div
                  className="/* TODO: Convert position: absolute */ /* TODO: Convert top: 20 */ /* TODO: Convert left: 50% */ /* TODO: Convert transform: translateX(-50%) */ /* TODO: Convert bgcolor: rgba(0 */ /* TODO: Convert color: white */ /* TODO: Convert px: 2 */ /* TODO: Convert py: 1 */ rounded-md /* TODO: Convert textAlign: center */"
                >
                  <Typography variant="body2">
                    Kliknite na üì∏ alebo stlaƒçte medzern√≠k na odfotenie
                  </Typography>
                </div>
              )}

              {/* Success indicator */}
              {photosInSession > 0 && (
                <div
                  className="/* TODO: Convert position: absolute */ /* TODO: Convert top: 20 */ /* TODO: Convert right: 20 */ /* TODO: Convert bgcolor: rgba(76 */ /* TODO: Convert color: white */ /* TODO: Convert px: 2 */ /* TODO: Convert py: 1 */ rounded-md /* TODO: Convert display: flex */ /* TODO: Convert alignItems: center */ gap-2"
                >
                  <CheckCircle className="/* TODO: Convert fontSize: 20 */" />
                  <Typography variant="body2">
                    {photosInSession} fotiek zachyten√Ωch
                  </Typography>
                </div>
              )}

              {/* üíæ FLOATING SAVE BUTTON - Hlavn√© tlaƒçidlo na ulo≈æenie */}
              {photosInSession > 0 && (
                <div
                  className="/* TODO: Convert position: absolute */ /* TODO: Convert top: 80 */ /* TODO: Convert // Pod success indik√°torom
                    right: 20 */ /* TODO: Convert zIndex: 1000 */"
                >
                  <Button
                    onClick={onClose}
                    variant="contained"
                    size="large"
                    startIcon={<CheckCircle />}
                    sx={{
                      bgcolor: '#4CAF50', // Zelen√° farba
                      color: 'white',
                      fontWeight: 'bold',
                      fontSize: '16px',
                      px: 3,
                      py: 1.5,
                      borderRadius: 3,
                      boxShadow: '0 4px 12px rgba(76, 175, 80, 0.4)',
                      '&:hover': {
                        bgcolor: '#45a049',
                        boxShadow: '0 6px 16px rgba(76, 175, 80, 0.6)',
                      },
                      '&:active': {
                        transform: 'scale(0.98)',
                      },
                      transition: 'all 0.2s ease',
                      minWidth: '160px',
                    }}
                  >
                    Ulo≈æi≈• fotky ({photosInSession})
                  </Button>
                </div>
              )}
            </div>
          </>
        )}
      </DialogContent>

      <DialogActions
        className="/* TODO: Convert bgcolor: rgba(0 */ /* TODO: Convert color: white */ /* TODO: Convert justifyContent: center */ /* TODO: Convert py: 1 */ /* TODO: Convert display: photosInSession > 0 ? flex : none */"
      >
        <Button
          onClick={onClose}
          className="/* TODO: Convert color: rgba(255 */ /* TODO: Convert fontSize: 14px */"
        >
          ‚úì Dokonƒçi≈• ({photosInSession} fotiek)
        </Button>
      </DialogActions>
    </Dialog>
  );
}
