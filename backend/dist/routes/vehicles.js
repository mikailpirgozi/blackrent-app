"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const postgres_database_1 = require("../models/postgres-database");
const auth_1 = require("../middleware/auth");
const permissions_1 = require("../middleware/permissions");
const cache_middleware_1 = require("../middleware/cache-middleware");
const router = (0, express_1.Router)();
// üîç CONTEXT FUNCTIONS
const getVehicleContext = async (req) => {
    const vehicleId = req.params.id;
    if (!vehicleId)
        return {};
    const vehicle = await postgres_database_1.postgresDatabase.getVehicle(vehicleId);
    return {
        resourceOwnerId: vehicle?.assignedMechanicId,
        resourceCompanyId: vehicle?.ownerCompanyId
    };
};
// GET /api/vehicles - Z√≠skanie v≈°etk√Ωch vozidiel s cache
router.get('/', auth_1.authenticateToken, (0, permissions_1.checkPermission)('vehicles', 'read'), (0, cache_middleware_1.cacheResponse)('vehicles', {
    cacheKey: cache_middleware_1.userSpecificCache,
    ttl: 10 * 60 * 1000, // 10 minutes
    tags: ['vehicles']
}), async (req, res) => {
    try {
        let vehicles = await postgres_database_1.postgresDatabase.getVehicles();
        console.log('üöó Vehicles GET - user:', {
            role: req.user?.role,
            userId: req.user?.id,
            totalVehicles: vehicles.length
        });
        // üîê NON-ADMIN USERS - filter podƒæa company permissions
        if (req.user?.role !== 'admin' && req.user) {
            const user = req.user; // TypeScript safe assignment
            const originalCount = vehicles.length;
            // Z√≠skaj company access pre pou≈æ√≠vateƒæa
            const userCompanyAccess = await postgres_database_1.postgresDatabase.getUserCompanyAccess(user.id);
            const allowedCompanyIds = userCompanyAccess.map(access => access.companyId);
            // Filter vozidl√° len pre firmy, ku ktor√Ωm m√° pou≈æ√≠vateƒæ pr√≠stup
            // ‚úÖ V≈°etky vozidl√° maj√∫ teraz owner_company_id - pou≈æ√≠vame len to
            vehicles = vehicles.filter(v => {
                return v.ownerCompanyId && allowedCompanyIds.includes(v.ownerCompanyId);
            });
            console.log('üîê Company Permission Filter:', {
                userId: user.id,
                allowedCompanyIds,
                userCompanyAccess: userCompanyAccess.map(a => ({ id: a.companyId, name: a.companyName })),
                originalCount,
                filteredCount: vehicles.length,
                sampleResults: vehicles.slice(0, 3).map(v => ({
                    licensePlate: v.licensePlate,
                    company: v.company,
                    ownerCompanyId: v.ownerCompanyId
                }))
            });
        }
        res.json({
            success: true,
            data: vehicles
        });
    }
    catch (error) {
        console.error('Get vehicles error:', error);
        res.status(500).json({
            success: false,
            error: 'Chyba pri z√≠skavan√≠ vozidiel'
        });
    }
});
// üß™ TEST endpoint pre CSV funkcionalitu
router.get('/test-csv', auth_1.authenticateToken, async (req, res) => {
    res.json({
        success: true,
        message: 'CSV endpointy s√∫ dostupn√©',
        timestamp: new Date().toISOString()
    });
});
// ‚ö° GET /api/vehicles/bulk-ownership-history - Hist√≥ria vlastn√≠ctva v≈°etk√Ωch vozidiel NARAZ
router.get('/bulk-ownership-history', auth_1.authenticateToken, (0, auth_1.requireRole)(['admin']), async (req, res) => {
    try {
        console.log('üöÄ BULK: Loading ownership history for all vehicles...');
        const startTime = Date.now();
        // ‚ö°‚ö° SKUTOƒåN√ù BULK: Jeden SQL query pre v≈°etky vehicle histories naraz
        const client = await postgres_database_1.postgresDatabase.pool.connect();
        try {
            // 1. Z√≠skaj v≈°etky vozidl√°
            const vehiclesResult = await client.query(`
          SELECT id, brand, model, license_plate, owner_company_id 
          FROM vehicles 
          ORDER BY brand, model
        `);
            const vehicles = vehiclesResult.rows;
            console.log(`üìä Loading history for ${vehicles.length} vehicles...`);
            // 2. Z√≠skaj v≈°etky ownership histories jedn√Ωm query
            const historiesResult = await client.query(`
          SELECT 
            vehicle_id,
            id,
            owner_company_id,
            owner_company_name,
            valid_from,
            valid_to,
            transfer_reason,
            transfer_notes
          FROM vehicle_ownership_history
          ORDER BY vehicle_id, valid_from DESC
        `);
            // 3. Group histories by vehicle_id
            const historiesByVehicle = new Map();
            historiesResult.rows.forEach((row) => {
                if (!historiesByVehicle.has(row.vehicle_id)) {
                    historiesByVehicle.set(row.vehicle_id, []);
                }
                historiesByVehicle.get(row.vehicle_id).push({
                    id: row.id,
                    ownerCompanyId: row.owner_company_id,
                    ownerCompanyName: row.owner_company_name,
                    validFrom: row.valid_from,
                    validTo: row.valid_to,
                    transferReason: row.transfer_reason,
                    transferNotes: row.transfer_notes
                });
            });
            // 4. Combine vehicle data with histories
            const allHistories = vehicles.map((vehicle) => ({
                vehicleId: vehicle.id,
                vehicle: {
                    id: vehicle.id,
                    brand: vehicle.brand,
                    model: vehicle.model,
                    licensePlate: vehicle.license_plate,
                    ownerCompanyId: vehicle.owner_company_id
                },
                history: historiesByVehicle.get(vehicle.id) || []
            }));
            const loadTime = Date.now() - startTime;
            console.log(`‚úÖ BULK: Loaded ownership history for ${vehicles.length} vehicles in ${loadTime}ms using 2 SQL queries instead of ${vehicles.length + 1}`);
            res.json({
                success: true,
                data: {
                    vehicleHistories: allHistories,
                    totalVehicles: vehicles.length,
                    loadTimeMs: loadTime
                }
            });
        }
        finally {
            client.release();
        }
    }
    catch (error) {
        console.error('Bulk ownership history error:', error);
        res.status(500).json({
            success: false,
            error: `Failed to load bulk ownership history: ${error instanceof Error ? error.message : 'Unknown error'}`
        });
    }
});
// GET /api/vehicles/:id - Z√≠skanie konkr√©tneho vozidla
router.get('/:id', auth_1.authenticateToken, (0, permissions_1.checkPermission)('vehicles', 'read', { getContext: getVehicleContext }), async (req, res) => {
    try {
        const { id } = req.params;
        const vehicle = await postgres_database_1.postgresDatabase.getVehicle(id);
        if (!vehicle) {
            return res.status(404).json({
                success: false,
                error: 'Vozidlo nen√°jden√©'
            });
        }
        res.json({
            success: true,
            data: vehicle
        });
    }
    catch (error) {
        console.error('Get vehicle error:', error);
        res.status(500).json({
            success: false,
            error: 'Chyba pri z√≠skavan√≠ vozidla'
        });
    }
});
// POST /api/vehicles - Vytvorenie nov√©ho vozidla s cache invalidation
router.post('/', auth_1.authenticateToken, (0, permissions_1.checkPermission)('vehicles', 'create'), (0, cache_middleware_1.invalidateCache)('vehicle'), async (req, res) => {
    try {
        const { brand, model, licensePlate, vin, company, pricing, commission, status, year } = req.body;
        if (!brand || !model || !company) {
            return res.status(400).json({
                success: false,
                error: 'V≈°etky povinn√© polia musia by≈• vyplnen√©'
            });
        }
        const createdVehicle = await postgres_database_1.postgresDatabase.createVehicle({
            brand,
            model,
            year: year || 2024,
            licensePlate: licensePlate || '',
            vin: vin || null,
            company,
            pricing: pricing || [],
            commission: commission || { type: 'percentage', value: 0 },
            status: status || 'available'
        });
        res.status(201).json({
            success: true,
            message: 'Vozidlo √∫spe≈°ne vytvoren√©',
            data: createdVehicle
        });
    }
    catch (error) {
        console.error('Create vehicle error:', error);
        const errorMessage = error instanceof Error ? error.message : 'Chyba pri vytv√°ran√≠ vozidla';
        res.status(500).json({
            success: false,
            error: errorMessage
        });
    }
});
// PUT /api/vehicles/:id - Aktualiz√°cia vozidla s cache invalidation
router.put('/:id', auth_1.authenticateToken, (0, permissions_1.checkPermission)('vehicles', 'update', { getContext: getVehicleContext }), (0, cache_middleware_1.invalidateCache)('vehicle'), async (req, res) => {
    try {
        const { id } = req.params;
        const { brand, model, licensePlate, vin, company, category, pricing, commission, status, year, stk } = req.body;
        // Skontroluj, ƒçi vozidlo existuje
        const existingVehicle = await postgres_database_1.postgresDatabase.getVehicle(id);
        if (!existingVehicle) {
            return res.status(404).json({
                success: false,
                error: 'Vozidlo nen√°jden√©'
            });
        }
        const updatedVehicle = {
            id,
            brand: brand || existingVehicle.brand,
            model: model || existingVehicle.model,
            licensePlate: licensePlate || existingVehicle.licensePlate,
            vin: vin !== undefined ? vin : existingVehicle.vin,
            company: company || existingVehicle.company,
            category: category || existingVehicle.category,
            pricing: pricing || existingVehicle.pricing,
            commission: commission || existingVehicle.commission,
            status: status || existingVehicle.status,
            year: year !== undefined ? year : existingVehicle.year,
            stk: stk !== undefined ? (stk ? new Date(stk) : undefined) : existingVehicle.stk,
            ownerCompanyId: existingVehicle.ownerCompanyId,
            assignedMechanicId: existingVehicle.assignedMechanicId,
            createdAt: existingVehicle.createdAt
        };
        await postgres_database_1.postgresDatabase.updateVehicle(updatedVehicle);
        res.json({
            success: true,
            message: 'Vozidlo √∫spe≈°ne aktualizovan√©',
            data: updatedVehicle
        });
    }
    catch (error) {
        console.error('Update vehicle error:', error);
        res.status(500).json({
            success: false,
            error: 'Chyba pri aktualiz√°cii vozidla'
        });
    }
});
// DELETE /api/vehicles/:id - Vymazanie vozidla s cache invalidation
router.delete('/:id', auth_1.authenticateToken, (0, permissions_1.checkPermission)('vehicles', 'delete', { getContext: getVehicleContext }), (0, cache_middleware_1.invalidateCache)('vehicle'), async (req, res) => {
    try {
        const { id } = req.params;
        // Skontroluj, ƒçi vozidlo existuje
        const existingVehicle = await postgres_database_1.postgresDatabase.getVehicle(id);
        if (!existingVehicle) {
            return res.status(404).json({
                success: false,
                error: 'Vozidlo nen√°jden√©'
            });
        }
        await postgres_database_1.postgresDatabase.deleteVehicle(id);
        res.json({
            success: true,
            message: 'Vozidlo √∫spe≈°ne vymazan√©'
        });
    }
    catch (error) {
        console.error('Delete vehicle error:', error);
        res.status(500).json({
            success: false,
            error: 'Chyba pri vymaz√°van√≠ vozidla'
        });
    }
});
// üîß ADMIN TOOL - Priradenie vozidiel k firme
router.post('/assign-to-company', auth_1.authenticateToken, (0, auth_1.requireRole)(['admin']), async (req, res) => {
    try {
        const { vehicleIds, companyId } = req.body;
        if (!vehicleIds || !Array.isArray(vehicleIds) || !companyId) {
            return res.status(400).json({
                success: false,
                error: 'vehicleIds (array) a companyId s√∫ povinn√©'
            });
        }
        // Verify company exists
        const companies = await postgres_database_1.postgresDatabase.getCompanies();
        const company = companies.find(c => c.id === companyId);
        if (!company) {
            return res.status(404).json({
                success: false,
                error: 'Firma nen√°jden√°'
            });
        }
        // Update vehicles using database method
        await postgres_database_1.postgresDatabase.assignVehiclesToCompany(vehicleIds, companyId);
        console.log(`üè¢ Assigned ${vehicleIds.length} vehicles to company ${company.name}`);
        res.json({
            success: true,
            message: `${vehicleIds.length} vozidiel √∫spe≈°ne priraden√Ωch k firme ${company.name}`,
            data: {
                companyId,
                companyName: company.name,
                assignedVehicleIds: vehicleIds
            }
        });
    }
    catch (error) {
        console.error('Assign vehicles to company error:', error);
        res.status(500).json({
            success: false,
            error: 'Chyba pri priradzovan√≠ vozidiel'
        });
    }
});
// üìä CSV EXPORT - Export vozidiel do CSV
router.get('/export/csv', auth_1.authenticateToken, (0, permissions_1.checkPermission)('vehicles', 'read'), async (req, res) => {
    try {
        let vehicles = await postgres_database_1.postgresDatabase.getVehicles();
        // üîê NON-ADMIN USERS - filter podƒæa company permissions
        if (req.user?.role !== 'admin' && req.user) {
            const userCompanyAccess = await postgres_database_1.postgresDatabase.getUserCompanyAccess(req.user.id);
            const allowedCompanyIds = userCompanyAccess.map(access => access.companyId);
            vehicles = vehicles.filter(v => v.ownerCompanyId && allowedCompanyIds.includes(v.ownerCompanyId));
        }
        // Vytvor CSV hlaviƒçky s cenotvorbou
        const csvHeaders = [
            'ID',
            'Znaƒçka',
            'Model',
            '≈†PZ',
            'Firma',
            'Rok',
            'Status',
            'STK',
            'Vytvoren√©',
            // üí∞ CENOTVORBA - 7 cenov√Ωch p√°siem
            'Cena_0-1_dni',
            'Cena_2-3_dni',
            'Cena_4-7_dni',
            'Cena_8-14_dni',
            'Cena_15-22_dni',
            'Cena_23-30_dni',
            'Cena_31+_dni',
            // üíº PROV√çZIA
            'Provizia_typ',
            'Provizia_hodnota'
        ];
        // Konvertuj vozidl√° na CSV riadky s cenotvorbou
        const csvRows = vehicles.map(vehicle => {
            // üí∞ EXTRAKCIA CENOTVORBY - 7 ≈°tandardn√Ωch p√°siem
            const pricing = vehicle.pricing || [];
            const getPriceForDays = (minDays, maxDays) => {
                const tier = pricing.find(p => p.minDays === minDays && p.maxDays === maxDays);
                return tier ? tier.pricePerDay : '';
            };
            return [
                vehicle.id,
                vehicle.brand,
                vehicle.model,
                vehicle.licensePlate,
                vehicle.company,
                vehicle.year || '',
                vehicle.status,
                vehicle.stk ? vehicle.stk.toISOString().split('T')[0] : '',
                vehicle.createdAt ? vehicle.createdAt.toISOString().split('T')[0] : '',
                // üí∞ CENOTVORBA - 7 cenov√Ωch p√°siem
                getPriceForDays(0, 1), // 0-1 dn√≠
                getPriceForDays(2, 3), // 2-3 dni
                getPriceForDays(4, 7), // 4-7 dn√≠
                getPriceForDays(8, 14), // 8-14 dn√≠
                getPriceForDays(15, 22), // 15-22 dn√≠
                getPriceForDays(23, 30), // 23-30 dn√≠
                getPriceForDays(31, 365), // 31+ dn√≠
                // üíº PROV√çZIA
                vehicle.commission?.type || 'percentage',
                vehicle.commission?.value || 20
            ];
        });
        // Vytvor CSV obsah
        const csvContent = [csvHeaders, ...csvRows]
            .map(row => row.map(field => `"${field}"`).join(','))
            .join('\n');
        // Nastav response headers pre CSV download
        res.setHeader('Content-Type', 'text/csv; charset=utf-8');
        res.setHeader('Content-Disposition', `attachment; filename="vozidla-${new Date().toISOString().split('T')[0]}.csv"`);
        res.setHeader('Cache-Control', 'no-cache');
        // Pridaj BOM pre spr√°vne zobrazenie diakritiky v Exceli
        res.send('\ufeff' + csvContent);
        console.log(`üìä CSV Export: ${vehicles.length} vozidiel exportovan√Ωch pre pou≈æ√≠vateƒæa ${req.user?.username}`);
    }
    catch (error) {
        console.error('CSV export error:', error);
        res.status(500).json({
            success: false,
            error: 'Chyba pri exporte CSV'
        });
    }
});
// üì• CSV IMPORT - Import vozidiel z CSV s kontrolou duplic√≠t a update
router.post('/import/csv', auth_1.authenticateToken, async (req, res) => {
    try {
        console.log('üì• Starting CSV import for vehicles...');
        const { csvData } = req.body;
        if (!csvData) {
            return res.status(400).json({
                success: false,
                error: 'CSV d√°ta s√∫ povinn√©'
            });
        }
        // Parsuj CSV d√°ta
        const lines = csvData.split('\n').filter((line) => line.trim());
        const header = lines[0].split(',').map((h) => h.replace(/^"|"$/g, '').trim());
        const dataLines = lines.slice(1); // Preskoƒçi≈• header
        console.log('üìä CSV Header:', header);
        const results = [];
        const errors = [];
        const updated = [];
        const skipped = [];
        console.log(`üìä Processing ${dataLines.length} vehicles from CSV...`);
        // Z√≠skaj existuj√∫ce vozidl√° pre kontrolu duplic√≠t
        const existingVehicles = await postgres_database_1.postgresDatabase.getVehicles();
        const existingByLicensePlate = new Map(existingVehicles.map(v => [v.licensePlate?.toLowerCase(), v]));
        // Progress tracking
        const progressInterval = Math.max(1, Math.floor(dataLines.length / 10)); // Log ka≈æd√Ωch 10% alebo ka≈æd√Ω z√°znam ak je menej ako 10
        for (let i = 0; i < dataLines.length; i++) {
            // Progress logging
            if (i % progressInterval === 0 || i === dataLines.length - 1) {
                const progress = Math.round(((i + 1) / dataLines.length) * 100);
                console.log(`üìä CSV Import Progress: ${progress}% (${i + 1}/${dataLines.length})`);
            }
            try {
                const line = dataLines[i].trim();
                if (!line)
                    continue;
                // Parsuj CSV riadok
                const fields = line.split(',').map((field) => field.replace(/^"|"$/g, '').trim());
                if (fields.length < 4) {
                    errors.push({ row: i + 2, error: 'Nedostatok stƒ∫pcov' });
                    continue;
                }
                // Mapovanie z√°kladn√Ωch stƒ∫pcov s podporou slovensk√Ωch n√°zvov
                const fieldMap = {};
                header.forEach((headerName, index) => {
                    fieldMap[headerName] = fields[index] || '';
                });
                // üîß OPRAVEN√â: Podpora slovensk√Ωch aj anglick√Ωch n√°zvov stƒ∫pcov
                const brand = fieldMap['brand'] || fieldMap['Znaƒçka'];
                const model = fieldMap['model'] || fieldMap['Model'];
                const licensePlate = fieldMap['licensePlate'] || fieldMap['≈†PZ'];
                const company = fieldMap['company'] || fieldMap['Firma'];
                const year = fieldMap['year'] || fieldMap['Rok'];
                const status = fieldMap['status'] || fieldMap['Status'];
                const stk = fieldMap['stk'] || fieldMap['STK'];
                if (!brand || !model || !company) {
                    errors.push({ row: i + 2, error: 'Znaƒçka, model a firma s√∫ povinn√©' });
                    continue;
                }
                // ‚úÖ PARSOVANIE CENOTVORBY Z CSV
                const pricing = [];
                // üí∞ MAPOVANIE CENOV√ùCH STƒπPCOV - podpora nov√Ωch n√°zvov z exportu
                const priceColumns = [
                    { columns: ['cena_0_1', 'Cena_0-1_dni'], minDays: 0, maxDays: 1 },
                    { columns: ['cena_2_3', 'Cena_2-3_dni'], minDays: 2, maxDays: 3 },
                    { columns: ['cena_4_7', 'Cena_4-7_dni'], minDays: 4, maxDays: 7 },
                    { columns: ['cena_8_14', 'Cena_8-14_dni'], minDays: 8, maxDays: 14 },
                    { columns: ['cena_15_22', 'Cena_15-22_dni'], minDays: 15, maxDays: 22 },
                    { columns: ['cena_23_30', 'Cena_23-30_dni'], minDays: 23, maxDays: 30 },
                    { columns: ['cena_31_9999', 'Cena_31+_dni'], minDays: 31, maxDays: 365 }
                ];
                priceColumns.forEach((priceCol, index) => {
                    // Sk√∫s n√°js≈• hodnotu v ktoromkoƒævek z mo≈æn√Ωch n√°zvov stƒ∫pcov
                    let priceValue = '';
                    for (const columnName of priceCol.columns) {
                        if (fieldMap[columnName]) {
                            priceValue = fieldMap[columnName];
                            break;
                        }
                    }
                    if (priceValue && !isNaN(parseFloat(priceValue))) {
                        pricing.push({
                            id: (index + 1).toString(),
                            minDays: priceCol.minDays,
                            maxDays: priceCol.maxDays,
                            pricePerDay: parseFloat(priceValue)
                        });
                    }
                });
                // üíº PARSOVANIE PROV√çZIE - podpora nov√Ωch n√°zvov z exportu
                const commissionType = (fieldMap['commissionType'] ||
                    fieldMap['Provizia_typ'] ||
                    'percentage');
                const commissionValue = fieldMap['commissionValue'] || fieldMap['Provizia_hodnota']
                    ? parseFloat(fieldMap['commissionValue'] || fieldMap['Provizia_hodnota'])
                    : 20;
                // Vytvor vehicle data
                const vehicleData = {
                    brand: brand.trim(),
                    model: model.trim(),
                    licensePlate: licensePlate?.trim() || '',
                    company: company.trim(),
                    year: year && year.trim() && !isNaN(parseInt(year)) ? parseInt(year) : 2024,
                    status: (status?.trim() || 'available'),
                    stk: stk && stk.trim() ? new Date(stk.trim()) : undefined,
                    pricing: pricing,
                    commission: {
                        type: commissionType,
                        value: commissionValue
                    }
                };
                // üîç KONTROLA DUPLIC√çT - Ak existuje vozidlo s rovnakou ≈†PZ
                const licensePlateLower = vehicleData.licensePlate.toLowerCase();
                const existingVehicle = existingByLicensePlate.get(licensePlateLower);
                if (existingVehicle) {
                    // ‚úÖ UPDATE EXISTUJ√öCEHO Z√ÅZNAMU
                    console.log(`üîÑ Updating existing vehicle ${i + 1}/${dataLines.length}: ${brand} ${model} (${licensePlate})`);
                    const updatedVehicle = {
                        ...existingVehicle,
                        brand: vehicleData.brand,
                        model: vehicleData.model,
                        company: vehicleData.company,
                        year: vehicleData.year,
                        status: vehicleData.status,
                        stk: vehicleData.stk,
                        pricing: vehicleData.pricing,
                        commission: vehicleData.commission
                    };
                    await postgres_database_1.postgresDatabase.updateVehicle(updatedVehicle);
                    updated.push({
                        id: existingVehicle.id,
                        brand: vehicleData.brand,
                        model: vehicleData.model,
                        licensePlate: vehicleData.licensePlate,
                        action: 'updated'
                    });
                }
                else {
                    // ‚úÖ VYTVOR NOV√â VOZIDLO
                    console.log(`üöó Creating new vehicle ${i + 1}/${dataLines.length}: ${brand} ${model} with ${pricing.length} price tiers`);
                    console.log('üí∞ Pricing:', pricing);
                    const createdVehicle = await postgres_database_1.postgresDatabase.createVehicle(vehicleData);
                    results.push({
                        id: createdVehicle.id,
                        brand: vehicleData.brand,
                        model: vehicleData.model,
                        licensePlate: vehicleData.licensePlate,
                        action: 'created'
                    });
                }
            }
            catch (error) {
                console.error(`‚ùå Error processing row ${i + 2}:`, error);
                errors.push({
                    row: i + 2,
                    error: error instanceof Error ? error.message : 'Nezn√°ma chyba'
                });
            }
        }
        console.log(`‚úÖ CSV import completed: ${results.length} created, ${updated.length} updated, ${errors.length} errors`);
        res.json({
            success: true,
            message: `CSV import dokonƒçen√Ω: ${results.length} vytvoren√Ωch, ${updated.length} aktualizovan√Ωch, ${errors.length} ch√Ωb`,
            data: {
                imported: results.length,
                updated: updated.length,
                errorsCount: errors.length,
                results: [...results, ...updated],
                errors: errors.slice(0, 10) // Limit na prv√Ωch 10 ch√Ωb
            }
        });
    }
    catch (error) {
        console.error('‚ùå CSV import error:', error);
        res.status(500).json({
            success: false,
            error: 'Chyba pri CSV importe',
            details: error instanceof Error ? error.message : 'Nezn√°ma chyba'
        });
    }
});
// üöÄ GMAIL APPROACH: GET /api/vehicles/paginated - R√Ωchle vyhƒæad√°vanie s pagination
router.get('/paginated', auth_1.authenticateToken, (0, permissions_1.checkPermission)('vehicles', 'read'), async (req, res) => {
    try {
        const { page = 1, limit = 50, search = '', company = 'all', brand = 'all', category = 'all', status = 'all', yearMin = '', yearMax = '', priceMin = '', priceMax = '' } = req.query;
        console.log('üöó Vehicles PAGINATED GET - params:', {
            page, limit, search, company, brand, category,
            role: req.user?.role,
            userId: req.user?.id
        });
        const pageNum = parseInt(page);
        const limitNum = parseInt(limit);
        const offset = (pageNum - 1) * limitNum;
        // Z√≠skaj paginated vehicles s filtrami
        const result = await postgres_database_1.postgresDatabase.getVehiclesPaginated({
            limit: limitNum,
            offset,
            search: search,
            company: company,
            brand: brand,
            category: category,
            status: status,
            yearMin: yearMin,
            yearMax: yearMax,
            priceMin: priceMin,
            priceMax: priceMax,
            userId: req.user?.id,
            userRole: req.user?.role
        });
        console.log(`üìä Found ${result.vehicles.length}/${result.total} vehicles (page ${pageNum})`);
        res.json({
            success: true,
            data: {
                vehicles: result.vehicles,
                pagination: {
                    currentPage: pageNum,
                    totalPages: Math.ceil(result.total / limitNum),
                    totalItems: result.total,
                    hasMore: (pageNum * limitNum) < result.total,
                    itemsPerPage: limitNum
                }
            }
        });
    }
    catch (error) {
        console.error('Get paginated vehicles error:', error);
        res.status(500).json({
            success: false,
            error: 'Chyba pri z√≠skavan√≠ vozidiel'
        });
    }
});
// üì• BATCH CSV IMPORT - R√Ωchly import viacer√Ωch vozidiel naraz
router.post('/batch-import', auth_1.authenticateToken, (0, permissions_1.checkPermission)('vehicles', 'create'), async (req, res) => {
    try {
        console.log('üì• Starting batch vehicle import...');
        const { vehicles } = req.body;
        if (!vehicles || !Array.isArray(vehicles)) {
            return res.status(400).json({
                success: false,
                error: 'Vehicles array je povinn√Ω'
            });
        }
        console.log(`üìä Processing ${vehicles.length} vehicles in batch...`);
        const results = [];
        const errors = [];
        const updated = [];
        let processed = 0;
        // Progress tracking
        const progressInterval = Math.max(1, Math.floor(vehicles.length / 10));
        // Z√≠skaj existuj√∫ce vozidl√° pre kontrolu duplic√≠t
        const existingVehicles = await postgres_database_1.postgresDatabase.getVehicles();
        const existingByLicensePlate = new Map(existingVehicles.map(v => [v.licensePlate?.toLowerCase(), v]));
        for (let i = 0; i < vehicles.length; i++) {
            // Progress logging
            if (i % progressInterval === 0 || i === vehicles.length - 1) {
                const progress = Math.round(((i + 1) / vehicles.length) * 100);
                console.log(`üìä Batch Import Progress: ${progress}% (${i + 1}/${vehicles.length})`);
            }
            try {
                const vehicleData = vehicles[i];
                // Valid√°cia povinn√Ωch pol√≠
                if (!vehicleData.brand || !vehicleData.model || !vehicleData.company) {
                    errors.push({
                        index: i + 1,
                        error: 'Znaƒçka, model a firma s√∫ povinn√©',
                        vehicle: `${vehicleData.brand || 'N/A'} ${vehicleData.model || 'N/A'}`
                    });
                    continue;
                }
                // Kontrola duplic√≠t podƒæa ≈†PZ
                const licensePlateLower = vehicleData.licensePlate?.toLowerCase();
                const existingVehicle = existingByLicensePlate.get(licensePlateLower);
                if (existingVehicle) {
                    // Update existuj√∫ceho vozidla
                    const updatedVehicle = {
                        ...existingVehicle,
                        ...vehicleData,
                        id: existingVehicle.id // Zachovaj origin√°lne ID
                    };
                    await postgres_database_1.postgresDatabase.updateVehicle(updatedVehicle);
                    updated.push({
                        id: existingVehicle.id,
                        brand: vehicleData.brand,
                        model: vehicleData.model,
                        licensePlate: vehicleData.licensePlate,
                        action: 'updated'
                    });
                }
                else {
                    // Vytvor nov√© vozidlo
                    const createdVehicle = await postgres_database_1.postgresDatabase.createVehicle(vehicleData);
                    results.push({
                        id: createdVehicle.id,
                        brand: vehicleData.brand,
                        model: vehicleData.model,
                        licensePlate: vehicleData.licensePlate,
                        action: 'created'
                    });
                }
                processed++;
            }
            catch (error) {
                console.error(`‚ùå Error processing vehicle ${i + 1}:`, error);
                errors.push({
                    index: i + 1,
                    error: error instanceof Error ? error.message : 'Nezn√°ma chyba',
                    vehicle: `${vehicles[i].brand || 'N/A'} ${vehicles[i].model || 'N/A'}`
                });
            }
        }
        const successRate = Math.round((processed / vehicles.length) * 100);
        console.log(`‚úÖ Batch vehicle import completed: ${results.length} created, ${updated.length} updated, ${errors.length} errors`);
        res.json({
            success: true,
            message: `Batch import dokonƒçen√Ω: ${results.length} vytvoren√Ωch, ${updated.length} aktualizovan√Ωch, ${errors.length} ch√Ωb`,
            data: {
                processed,
                total: vehicles.length,
                created: results.length,
                updated: updated.length,
                errorsCount: errors.length,
                successRate: `${successRate}%`,
                results: [...results, ...updated],
                errors: errors.slice(0, 10) // Limit na prv√Ωch 10 ch√Ωb
            }
        });
    }
    catch (error) {
        console.error('‚ùå Batch vehicle import failed:', error);
        res.status(500).json({
            success: false,
            error: 'Batch import vozidiel zlyhal',
            message: error instanceof Error ? error.message : String(error)
        });
    }
});
exports.default = router;
//# sourceMappingURL=vehicles.js.map