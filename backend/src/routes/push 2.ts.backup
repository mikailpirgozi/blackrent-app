// üîî Push Notifications API Routes
// Backend implementation for push notification management

import express from 'express';
import webpush from 'web-push';
import { authenticateToken, requireRole } from '../middleware/auth';
import { postgresDatabase } from '../models/postgres-database';

// Interface pre PostgreSQL query v√Ωsledky
interface QueryResult {
  rows: Record<string, unknown>[];
  rowCount?: number;
}

const router = express.Router();

// VAPID keys configuration
const VAPID_PUBLIC_KEY = process.env.VAPID_PUBLIC_KEY || '';
const VAPID_PRIVATE_KEY = process.env.VAPID_PRIVATE_KEY || '';
const VAPID_SUBJECT = process.env.VAPID_SUBJECT || 'mailto:admin@blackrent.sk';

// Initialize web-push with VAPID keys
if (VAPID_PUBLIC_KEY && VAPID_PRIVATE_KEY && VAPID_PUBLIC_KEY !== 'your-vapid-public-key' && VAPID_PRIVATE_KEY !== 'your-vapid-private-key') {
  try {
    webpush.setVapidDetails(
      VAPID_SUBJECT,
      VAPID_PUBLIC_KEY,
      VAPID_PRIVATE_KEY
    );
    console.log('‚úÖ Web Push VAPID keys configured');
  } catch (error) {
    console.warn('‚ö†Ô∏è VAPID keys configuration failed:', error);
  }
} else {
  console.warn('‚ö†Ô∏è VAPID keys not configured - push notifications will not work');
}

// Get VAPID public key
router.get('/vapid-key', (req, res) => {
  res.json({
    publicKey: VAPID_PUBLIC_KEY
  });
});

// Subscribe to push notifications
router.post('/subscription', authenticateToken, async (req, res) => {
  try {
    const { subscription, timestamp, userAgent } = req.body;
    const userId = req.user?.id;

    if (!subscription || !subscription.endpoint) {
      return res.status(400).json({
        error: 'Invalid subscription data'
      });
    }

    // Store subscription in database
    const result = await postgresDatabase.query(
      `INSERT INTO push_subscriptions (
        user_id, endpoint, p256dh_key, auth_key, user_agent, created_at, updated_at
      ) VALUES ($1, $2, $3, $4, $5, NOW(), NOW())
      ON CONFLICT (user_id, endpoint) 
      DO UPDATE SET 
        p256dh_key = $3,
        auth_key = $4,
        user_agent = $5,
        updated_at = NOW()
      RETURNING id`,
      [
        userId,
        subscription.endpoint,
        subscription.keys?.p256dh || '',
        subscription.keys?.auth || '',
        userAgent || ''
      ]
    ) as QueryResult;

    console.log(`‚úÖ Push subscription saved for user ${userId}`);

    res.json({
      success: true,
      subscriptionId: result.rows[0]?.id
    });

  } catch (error) {
    console.error('‚ùå Error saving push subscription:', error);
    res.status(500).json({
      error: 'Failed to save subscription'
    });
  }
});

// Unsubscribe from push notifications
router.delete('/subscription', authenticateToken, async (req, res) => {
  try {
    const { endpoint } = req.body;
    const userId = req.user?.id;

    await postgresDatabase.query(
      'DELETE FROM push_subscriptions WHERE user_id = $1 AND endpoint = $2',
      [userId, endpoint]
    );

    console.log(`‚úÖ Push subscription removed for user ${userId}`);

    res.json({
      success: true
    });

  } catch (error) {
    console.error('‚ùå Error removing push subscription:', error);
    res.status(500).json({
      error: 'Failed to remove subscription'
    });
  }
});

// Send push notification (admin only)
router.post('/send', authenticateToken, requireRole(['admin']), async (req, res) => {
  try {
    const {
      title,
      body,
      icon,
      badge,
      image,
      tag,
      data = {},
      actions = [],
      targetUsers = [], // Empty array means send to all
      requireInteraction = false,
      silent = false,
      vibrate,
      ttl = 86400 // 24 hours
    } = req.body;

    if (!title || !body) {
      return res.status(400).json({
        error: 'Title and body are required'
      });
    }

    // Get target subscriptions
    let query = 'SELECT * FROM push_subscriptions WHERE active = true';
    const params: any[] = [];

    if (targetUsers.length > 0) {
      query += ` AND user_id = ANY($1)`;
      params.push(targetUsers);
    }

    const subscriptions = await postgresDatabase.query(query, params) as QueryResult;

    if (subscriptions.rows.length === 0) {
      return res.status(404).json({
        error: 'No active subscriptions found'
      });
    }

    // Prepare notification payload
    const notificationPayload = {
      title,
      body,
      icon: icon || '/logo192.png',
      badge: badge || '/favicon.ico',
      image,
      tag: tag || `notification-${Date.now()}`,
      data: {
        ...data,
        timestamp: Date.now(),
        url: data.url || '/',
        clickAction: data.clickAction || 'open_app'
      },
      actions: actions.map((action: any) => ({
        action: action.action,
        title: action.title,
        icon: action.icon
      })),
      requireInteraction,
      silent,
      vibrate: vibrate || [200, 100, 200],
      timestamp: Date.now()
    };

    // Send notifications to all subscriptions
    const sendPromises = subscriptions.rows.map(async (sub: Record<string, unknown>) => {
      try {
        const pushSubscription = {
          endpoint: sub.endpoint as string,
          keys: {
            p256dh: sub.p256dh_key as string,
            auth: sub.auth_key as string
          }
        };

        await webpush.sendNotification(
          pushSubscription,
          JSON.stringify(notificationPayload),
          {
            TTL: ttl,
            urgency: requireInteraction ? 'high' : 'normal'
          }
        );

        // Log successful delivery
        await logNotificationDelivery(sub.id as string, 'sent', notificationPayload);
        
        return { subscriptionId: sub.id, status: 'sent' };

      } catch (error: any) {
        console.error(`‚ùå Failed to send to subscription ${sub.id}:`, error);

        // Handle expired subscriptions
        if (error.statusCode === 410 || error.statusCode === 404) {
          await postgresDatabase.query(
            'UPDATE push_subscriptions SET active = false WHERE id = $1',
            [sub.id]
          );
          console.log(`üóëÔ∏è Deactivated expired subscription ${sub.id}`);
        }

        await logNotificationDelivery(sub.id as string, 'failed', notificationPayload, error.message);
        
        return { subscriptionId: sub.id, status: 'failed', error: error.message };
      }
    });

    const results = await Promise.all(sendPromises);
    
    const summary = {
      total: results.length,
      sent: results.filter((r: { status: string }) => r.status === 'sent').length,
      failed: results.filter((r: { status: string }) => r.status === 'failed').length
    };

    console.log(`üìä Push notification summary:`, summary);

    res.json({
      success: true,
      summary,
      results: results
    });

  } catch (error) {
    console.error('‚ùå Error sending push notifications:', error);
    res.status(500).json({
      error: 'Failed to send notifications'
    });
  }
});

// Send targeted notification to specific user
router.post('/send-to-user/:userId', authenticateToken, requireRole(['admin', 'manager']), async (req, res) => {
  try {
    const { userId } = req.params;
    const notificationData = req.body;

    // Get user subscriptions
    const subscriptions = await postgresDatabase.query(
      'SELECT * FROM push_subscriptions WHERE user_id = $1 AND active = true',
      [userId]
    );

    if ((subscriptions as QueryResult).rows.length === 0) {
      return res.status(404).json({
        error: 'No active subscriptions found for user'
      });
    }

    // Send notification using the main send logic
    const sendResult = await sendPushNotificationToSubscriptions(
      (subscriptions as QueryResult).rows,
      notificationData
    );

    res.json(sendResult);

  } catch (error) {
    console.error('‚ùå Error sending targeted notification:', error);
    res.status(500).json({
      error: 'Failed to send notification'
    });
  }
});

// Get notification analytics
router.get('/analytics', authenticateToken, requireRole(['admin']), async (req, res) => {
  try {
    const { startDate, endDate, userId } = req.query;

    let query = `
      SELECT 
        DATE(created_at) as date,
        status,
        COUNT(*) as count
      FROM notification_logs 
      WHERE created_at >= $1 AND created_at <= $2
    `;
    
    const params = [
      startDate || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), // 30 days ago
      endDate || new Date()
    ];

    if (userId) {
      query += ' AND user_id = $3';
      params.push(userId as string);
    }

    query += ' GROUP BY DATE(created_at), status ORDER BY date DESC';

    const analytics = await postgresDatabase.query(query, params);

    // Get subscription stats
    const subscriptionStats = await postgresDatabase.query(`
      SELECT 
        COUNT(*) as total_subscriptions,
        COUNT(*) FILTER (WHERE active = true) as active_subscriptions,
        COUNT(*) FILTER (WHERE created_at >= NOW() - INTERVAL '7 days') as new_this_week
      FROM push_subscriptions
    `);

    res.json({
      analytics: (analytics as QueryResult).rows,
      subscriptionStats: (subscriptionStats as QueryResult).rows[0]
    });

  } catch (error) {
    console.error('‚ùå Error getting notification analytics:', error);
    res.status(500).json({
      error: 'Failed to get analytics'
    });
  }
});

// Get user's subscription status
router.get('/subscription/status', authenticateToken, async (req, res) => {
  try {
    const userId = req.user?.id;

    const subscriptions = await postgresDatabase.query(
      'SELECT id, endpoint, active, created_at FROM push_subscriptions WHERE user_id = $1',
      [userId]
    );

    res.json({
      subscriptions: subscriptions.rows,
      hasActiveSubscription: subscriptions.rows.some((sub: Record<string, unknown>) => sub.active)
    });

  } catch (error) {
    console.error('‚ùå Error getting subscription status:', error);
    res.status(500).json({
      error: 'Failed to get subscription status'
    });
  }
});

// Business logic notification triggers
router.post('/trigger/rental-request', authenticateToken, async (req, res) => {
  try {
    const { rentalId, customerId, vehicleId } = req.body;

    // Get rental details
    const rental = await postgresDatabase.query(
      `SELECT r.*, c.name as customer_name, v.brand, v.model 
       FROM rentals r 
       JOIN customers c ON r.customer_id = c.id 
       JOIN vehicles v ON r.vehicle_id = v.id 
       WHERE r.id = $1`,
      [rentalId]
    );

    if ((rental as QueryResult).rows.length === 0) {
      return res.status(404).json({ error: 'Rental not found' });
    }

    const rentalData = (rental as QueryResult).rows[0];

    // Send notification to admins
    const adminUsers = await postgresDatabase.query(
      "SELECT id FROM users WHERE role IN ('admin', 'manager')"
    );

    const notificationData = {
      title: 'üöó Nov√° ≈æiados≈• o pren√°jom',
      body: `${rentalData.customer_name} ≈æiada pren√°jom ${rentalData.brand} ${rentalData.model}`,
      icon: '/logo192.png',
      tag: `rental-request-${rentalId}`,
      data: {
        rentalId,
        customerId,
        vehicleId,
        url: `/rentals/${rentalId}`,
        clickAction: 'view_rental'
      },
      actions: [
        {
          action: 'approve_rental',
          title: '‚úÖ Schv√°li≈•',
          icon: '/icons/approve.png'
        },
        {
          action: 'reject_rental',
          title: '‚ùå Zamietnu≈•',
          icon: '/icons/reject.png'
        },
        {
          action: 'view_rental',
          title: 'üëÅÔ∏è Zobrazi≈•',
          icon: '/icons/view.png'
        }
      ],
      requireInteraction: true
    };

    // Send to admin subscriptions
    const adminSubscriptions = await postgresDatabase.query(
      `SELECT ps.* FROM push_subscriptions ps 
       JOIN users u ON ps.user_id = u.id 
       WHERE u.role IN ('admin', 'manager') AND ps.active = true`
    );

    const result = await sendPushNotificationToSubscriptions(
      (adminSubscriptions as QueryResult).rows,
      notificationData
    );

    res.json(result);

  } catch (error) {
    console.error('‚ùå Error triggering rental request notification:', error);
    res.status(500).json({
      error: 'Failed to trigger notification'
    });
  }
});

// Helper function to send notifications to multiple subscriptions
async function sendPushNotificationToSubscriptions(subscriptions: any[], notificationData: any) {
  const notificationPayload = {
    title: notificationData.title,
    body: notificationData.body,
    icon: notificationData.icon || '/logo192.png',
    badge: notificationData.badge || '/favicon.ico',
    image: notificationData.image,
    tag: notificationData.tag || `notification-${Date.now()}`,
    data: {
      ...notificationData.data,
      timestamp: Date.now()
    },
    actions: notificationData.actions || [],
    requireInteraction: notificationData.requireInteraction || false,
    silent: notificationData.silent || false,
    vibrate: notificationData.vibrate || [200, 100, 200],
    timestamp: Date.now()
  };

  const sendPromises = subscriptions.map(async (sub: any) => {
    try {
      const pushSubscription = {
        endpoint: sub.endpoint,
        keys: {
          p256dh: sub.p256dh_key,
          auth: sub.auth_key
        }
      };

      await webpush.sendNotification(
        pushSubscription,
        JSON.stringify(notificationPayload),
        {
          TTL: notificationData.ttl || 86400,
          urgency: notificationData.requireInteraction ? 'high' : 'normal'
        }
      );

      await logNotificationDelivery(sub.id, 'sent', notificationPayload);
      return { subscriptionId: sub.id, status: 'sent' };

    } catch (error: any) {
      console.error(`‚ùå Failed to send to subscription ${sub.id}:`, error);

      if (error.statusCode === 410 || error.statusCode === 404) {
        await postgresDatabase.query(
          'UPDATE push_subscriptions SET active = false WHERE id = $1',
          [sub.id]
        );
      }

      await logNotificationDelivery(sub.id, 'failed', notificationPayload, error.message);
      return { subscriptionId: sub.id, status: 'failed', error: error.message };
    }
  });

  const results = await Promise.all(sendPromises);
  
  return {
    success: true,
    summary: {
      total: results.length,
      sent: results.filter((r: { status: string }) => r.status === 'sent').length,
      failed: results.filter((r: { status: string }) => r.status === 'failed').length
    },
    results
  };
}

// Log notification delivery for analytics
async function logNotificationDelivery(
  subscriptionId: string, 
  status: string, 
  payload: any, 
  errorMessage?: string
) {
  try {
    await postgresDatabase.query(
      `INSERT INTO notification_logs (
        subscription_id, status, payload, error_message, created_at
      ) VALUES ($1, $2, $3, $4, NOW())`,
      [subscriptionId, status, JSON.stringify(payload), errorMessage || null]
    );
  } catch (error) {
    console.error('‚ùå Error logging notification delivery:', error);
  }
}

export default router;
